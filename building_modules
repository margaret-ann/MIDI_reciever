//code for 7-bit shift register
module shiftReg(dataOut, dataIn, muxIn, clk);

  input dataIn, muxIn, clk;
  output reg [6:0] dataOut;
  
  //functionality code
  always @(posedge muxIn, posedge clk)
    if(muxIn) //muxIn=1: buffer DFF output to input
      dataOut <= dataOut;
    else begin //muxIn=0: shift
      dataOut[0] <= dataOut[1];
      dataOut[1] <= dataOut[2];
      dataOut[2] <= dataOut[3];
      dataOut[3] <= dataOut[4];
      dataOut[4] <= dataOut[5];
      dataOut[5] <= dataOut[6];
      dataOut[6] <= dataIn;
    end
  
endmodule

//Testbench used to test ShiftReg
/*module SR_test;

  reg dataIn, muxIn, clk;
  wire [6:0] dataOut;
  
  shiftReg sr_block (dataOut, dataIn, muxIn, clk);
  
  initial begin
    
    $dumpfile("shiftReg.vcd");
    $dumpvars(0,SR_test);

	//fill reg with ones
    dataIn = 1;
    muxIn = 0;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in zero
    dataIn=0;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in one
    dataIn=1;
    clk=0; # 1;
    clk=1; # 1;
    
    //now buffer
    muxIn=1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    
    $finish;
  end
  
endmodule*/

//code for D Flip Flop with enable
module DFF(data0, data1, clk, enable, dataOut);

  input data0, data1, clk, enable;
  output reg dataOut;
  
  always @(posedge clk)
    if(enable) //fill DFF with mux input 1
      dataOut <= data1;
  	else //fill DFF with mux input 0
      dataOut <= data0;
      
endmodule

module fa (a,b,ci,s,co);
  input wire a,b,ci;
  output wire s, co;
  co = ((a&b)|(a&ci)|(b&ci));
  assign s = (a+b+ci)%2;
endmodule

module fa3 (a,b,ci,s,co);
  input wire [2:0] a, b;
  input wire ci;
  output wire [2:0] s;
  output wire co;
  wire [1:0] c;
  fa add1(a[0], b[0], ci, s[0], c[0]);
  fa add2(a[1], b[1], c[0], s[1], c[1]);
  fa add3(a[2], b[2], c[1], s[2], co);
endmodule

module fa6 (a,b,ci,s,co);
  input wire [5:0] a, b;
  input wire ci;
  output wire [5:0] s;
  output wire co; 
  wire c;
  fa3 add1(a[2:0], b[2:0], ci, s[2:0], c);
  fa3 add2(a[5:3], b[5:3], c, s[5:3], co);
endmodule

module mux(a, b, s, o);
  output wire o;
  input wire a, b, s; // a for 0 and b for 1
  assign o = s ? b : a;
endmodule

module mux3 (a, b, s, o);
  output wire [2:0] o;
  input wire [2:0] a, b; // a for 0 and b for 1
  input wire s;
  assign o = s ? b : a;
endmodule

module mux6 (a, b, s, o);
  output wire [5:0] o;
  input wire [5:0] a, b; // a for 0 and b for 1
  input wire s;  
  assign o = s ? b : a;
endmodule
/*
module device(in,clk_128,wire1);
  input wire in, clk_128, wire1;
  wire bytedetin
  reg bytedet, timing;
  reg [6:0] data;
  reg [2:0] bitcount, bytecount;
  mux myboy(1'b0, timing, wire1, bytedetin);
  always@(posedge clk_128)
    timing <= in;
    bytedet <= bytedetin;
  end
endmodule
*/
