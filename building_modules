//THREE BIT COUNTER
module count3(clk, reset, outBits);

  parameter n = 3;
  input wire clk, reset;
  output wire [n-1:0] outBits;
  wire [n-1:0] dataWire;
   
  //bring in some modules
  //not(clk, clk);
  dff DFF(dataWire[0], clk, reset, outBits[0]);
  //first FF, directly clked
  not(dataWire[0], outBits[0]); //set input to ~Q
  
  genvar i;
  for(i=1; i<n; i=i+1) begin
    dff DFF(dataWire[i], ~outBits[i-1], reset, outBits[i]);
    //build subsequent FFs
    not(dataWire[i], outBits[i]);
  end
  
endmodule

//FOUR BIT COUNTER
module count4(clk, reset, outBits);

  parameter n = 4;
  input wire clk, reset;
  output wire [n-1:0] outBits;
  wire [n-1:0] dataWire;
   
  //bring in some modules
  //not(clk, clk);
  dff DFF(dataWire[0], clk, reset, outBits[0]);
  //first FF, directly clked
  not(dataWire[0], outBits[0]); //set input to ~Q
  
  genvar i;
  for(i=1; i<n; i=i+1) begin
    dff DFF(dataWire[i], ~outBits[i-1], reset, outBits[i]);
    //build subsequent FFs
    not(dataWire[i], outBits[i]);
  end
  
endmodule

//SEVEN BIT COUNTER
module count7(clk, reset, outBits);

  parameter n = 7;
  input wire clk, reset;
  output wire [n-1:0] outBits;
  wire [n-1:0] dataWire;
   
  //bring in some modules
  //not(clk, clk);
  dff DFF(dataWire[0], clk, reset, outBits[0]);
  //first FF, directly clked
  not(dataWire[0], outBits[0]); //set input to ~Q
  
  genvar i;
  for(i=1; i<n; i=i+1) begin
    dff DFF(dataWire[i], ~outBits[i-1], reset, outBits[i]);
    //build subsequent FFs
    not(dataWire[i], outBits[i]);
  end
  
endmodule

//TEST COUNTERS
/*module counter_test;

  reg clk, data, reset;
  wire [1:0] dataOut;
  
  countN count_block (clk, reset, dataOut);
  
  initial begin
    
    $dumpfile("countN.vcd");
    $dumpvars(0,counter_test);

	//fill reg with ones
    reset=1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    
    reset=0;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    
    $finish;
  end
  
endmodule*/


//code for 7-bit shift register
module shiftReg(dataOut, dataIn, muxIn, clk);

  input dataIn, muxIn, clk;
  output reg [6:0] dataOut;
  
  //functionality code
  always @(posedge muxIn, posedge clk)
    if(muxIn) //muxIn=1: buffer DFF output to input
      dataOut <= dataOut;
    else begin //muxIn=0: shift
      dataOut[0] <= dataOut[1];
      dataOut[1] <= dataOut[2];
      dataOut[2] <= dataOut[3];
      dataOut[3] <= dataOut[4];
      dataOut[4] <= dataOut[5];
      dataOut[5] <= dataOut[6];
      dataOut[6] <= dataIn;
    end
  
endmodule

//Testbench used to test ShiftReg
/*module SR_test;

  reg dataIn, muxIn, clk;
  wire [6:0] dataOut;
  
  shiftReg sr_block (dataOut, dataIn, muxIn, clk);
  
  initial begin
    
    $dumpfile("shiftReg.vcd");
    $dumpvars(0,SR_test);

	//fill reg with ones
    dataIn = 1;
    muxIn = 0;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in zero
    dataIn=0;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in one
    dataIn=1;
    clk=0; # 1;
    clk=1; # 1;
    
    //now buffer
    muxIn=1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    
    $finish;
  end
  
endmodule*/

//code for D Flip Flop with enable
module dff(data, clk, reset, dataOut);

  input data, clk, reset;
  output reg dataOut;
  
  always @(posedge clk, posedge reset)
    if(reset) //mux 0 = reset
      dataOut <= 1'b0;
  	else //mux 1 = pass data to dff 
      dataOut <= data;
      
endmodule

module mux(a, b, s, o);
  output wire o;
  input wire a, b, s; // a for 0 and b for 1
  assign o = s ? b : a;
endmodule

module mux7 (a, b, s, o);
  output wire [6:0] o;
  input wire [6:0] a, b; // a for 0 and b for 1
  input wire s;  
  assign o = s ? b : a;
endmodule



module device(in, clk, led);
  input wire in, clk;
  output wire [6:0] led, preled;
  wire clk_128, wire1, in_star, bytcntrl, regcntrl, regmuxin, ledcntrl;
  
  sampler i(in, wire1, in_star, clk_128, clk);
  bitcount b(clk_128, in_star, bytcntrl, wire1);
  bytecount B(clk_128, bytcntrl, regcntrl, ledcntrl);
  assign regmuxin = regcntrl|wire1;
  shiftReg s(preled, in_star, regmuxin, clk_128);
  mux7 m(7'b0000000, preled, ledcntrl, led);
  
endmodule

module bytecount(clk_128, in, regcntrl, ledcntrl);
  input wire in, clk_128;
  output wire regcntrl, ledcntrl;
  wire reset;
  wire [2:0] cnt;
  assign reset = (~cnt[0]&cnt[1]&cnt[2]);
  assign ledcntrl = (~cnt[2]&cnt[1]);
  assign regcntrl = (~cnt[1]|cnt[0]|cnt[2]);
  count4 countie(in, reset, cnt);
  
endmodule

module bitcount(clk_128, in, bytcntrl, reset);
  input wire in, clk_128;
  output wire bytcntrl, reset;
  wire [3:0] cnt;
  reg bitreg;
  wire bitregin;
  
  assign reset = (cnt[3]|bitreg);
  assign bytcntrl = (~bitregin & bitreg);
  
  mux muxie(1'b0, in, reset, bitregin);
  count4 countee(clk_128, reset, cnt);
  
  always@(posedge clk_128) begin
    bitreg <= bitregin;  
  end
  
endmodule
