//code for 7-bit shift register
module shiftReg(dataOut, dataIn, muxIn, clk);

  input dataIn, muxIn, clk;
  output reg [6:0] dataOut;
  
  //functionality code
  always @(posedge muxIn, posedge clk)
    if(muxIn) //muxIn=1: buffer DFF output to input
      dataOut <= dataOut;
    else begin //muxIn=0: shift
      dataOut[0] <= dataOut[1];
      dataOut[1] <= dataOut[2];
      dataOut[2] <= dataOut[3];
      dataOut[3] <= dataOut[4];
      dataOut[4] <= dataOut[5];
      dataOut[5] <= dataOut[6];
      dataOut[6] <= dataIn;
    end
  
endmodule

//Testbench used to test ShiftReg
/*module SR_test;

  reg dataIn, muxIn, clk;
  wire [6:0] dataOut;
  
  shiftReg sr_block (dataOut, dataIn, muxIn, clk);
  
  initial begin
    
    $dumpfile("shiftReg.vcd");
    $dumpvars(0,SR_test);

	//fill reg with ones
    dataIn = 1;
    muxIn = 0;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in zero
    dataIn=0;
    clk=0; # 1;
    clk=1; # 1;
    
    //shift in one
    dataIn=1;
    clk=0; # 1;
    clk=1; # 1;
    
    //now buffer
    muxIn=1;
    clk=0; # 1;
    clk=1; # 1;
    clk=0; # 1;
    
    $finish;
  end
  
endmodule*/

//code for D Flip Flop with enable
module DFF(data0, data1, clk, enable, dataOut);

  input data0, data1, clk, enable;
  output reg dataOut;
  
  always @(posedge clk)
    if(enable) //fill DFF with mux input 1
      dataOut <= data1;
  	else //fill DFF with mux input 0
      dataOut <= data0;
      
endmodule

module mux(a, b, s, o);
  output wire o;
  input wire a, b, s; // a for 0 and b for 1
  assign o = s ? b : a;
endmodule

module mux7 (a, b, s, o);
  output wire [6:0] o;
  input wire [6:0] a, b; // a for 0 and b for 1
  input wire s;  
  assign o = s ? b : a;
endmodule



module device(in, clk, led);
  input wire in, clk;
  output wire [6:0] led, preled;
  wire clk_128, wire1, in_star, bytcntrl, regcntrl, regmuxin, ledcntrl;
  
  //sampler i(in, wire1, in_star, clk_128, clk);
  bitcount b(clk_128, in_star, bytcntrl, wire1);
  bytecount B(clk_128, bytcntrl, regcntrl, ledcntrl);
  assign regmuxin = regcntrl|wire1;
  shiftReg s(preled, in_star, regmuxin, clk_128);
  mux7 m(7'b0000000, preled, ledcntrl, led);
  
endmodule

module bytecount(clk_128, in, regcntrl, ledcntrl);
  input wire in, clk_128;
  output wire regcntrl, ledcntrl;
  wire reset;
  wire [2:0] cnt;
  assign reset = (~cnt[0]&cnt[1]&cnt[2]);
  assign ledcntrl = (~cnt[2]&cnt[1]);
  assign regcntrl = (~cnt[1]|cnt[0]|cnt[2]);
  //3cnt countie(in, reset, cnt);
  
endmodule

module bitcount(clk_128, in, bytcntrl, reset);
  input wire in, clk_128;
  output wire bytcntrl, reset;
  wire [3:0] cnt;
  reg bitreg;
  wire bitregin;
  
  assign reset = (cnt[3]|bitreg);
  assign bytcntrl = (~bitregin & bitreg);
  
  mux muxie(1'b0, in, reset, bitregin);
  //4cnt countee(in, reset, cnt);
  
  always@(posedge clk_128) begin
    bitreg <= bitregin;  
  end
  
endmodule
